%{ open Ast %}

%token INCREMENT DECREMENT MINUS_ASSIGN PLUS_ASSIGN TIMES_ASSIGN DIVIDE_ASSIGN
%token MODULO_ASSIGN MINUS PLUS TIMES DIVIDE MODULO LEFT_SHIFT_ASSIGN
%token RIGHT_SHIFT_ASSIGN BITWISE_AND_ASSIGN BITWISE_OR_ASSIGN BITWISE_XOR_ASSIGN
%token LEFT_SHIFT RIGHT_SHIFT BITWISE_NOT BITWISE_AND BITWISE_OR BITWISE_XOR
%token LESS_EQUAL GREATER_EQUAL NOT_EQUAL EQUAL NOT AND OR LESS GREATER ASSIGN
%token LEFT_PARENTHESIS RIGHT_PARENTHESIS LEFT_CURLY_BRACKET RIGHT_CURLY_BRACKET
%token SEMI_COLON COMMA FOR WHILE IF ELSE GOTO RETURN
%token <int> LITERAL
%token <string> IDENTIFIER

%left SEMI_COLON
%left COMMA
%left LEFT_CURLY_BRACKET RIGHT_CURLY_BRACKET
%left BITWISE_AND_ASSIGN BITWISE_XOR_ASSIGN BITWISE_OR_ASSIGN
%left LEFT_SHIFT_ASSIGN RIGHT_SHIFT_ASSIGN
%left TIMES_ASSIGN DIVIDE_ASSIGN MODULO_ASSIGN
%left PLUS_ASSIGN MINUS_ASSIGN
%left ASSIGN
%left OR
%left AND
%left BITWISE_AND BITWISE_XOR BITWISE_OR
%left EQUAL NOT_EQUAL
%left GREATER GREATER_EQUAL
%left LESS LESS_EQUAL
%left LEFT_SHIFT RIGHT_SHIFT
(*%left PLUS MINUS (* is it ok ?? unary/binary *)*)
%left TIMES DIVIDE MODULO
%right NOT BITWISE_NOT
%left LEFT_PARENTHESIS RIGHT_PARENTHESIS
%left PLUS MINUS (* is it ok ?? unary/binary *)
%left INCREMENT DECREMENT
%left FOR WHILE IF ELSE GOTO RETURN


%start expr
%type < Ast.expr> expr

%%

expr:
  expr PLUS   expr { Binop($1, Add, $3) }
| expr MINUS  expr { Binop($1, Sub, $3) }
| expr TIMES  expr { Binop($1, Mul, $3) }
| expr DIVIDE expr { Binop($1, Div, $3) }
| LITERAL          { Lit($1) }

