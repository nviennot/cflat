# The first line that doesn't start with a '#' should be the compiler command.
# It should read source code from stdin and produce an executable named
# 'temp.exe'.
bash -c '(./microc > temp.s && gcc -m32 -c temp.s -o temp.o && gcc -m32 temp.o lib.o -o temp.exe)'

After the compiler command, anything not within a test case (surrounded by ...)
is ignored.
The closing ... should be followed by a space and then the desired result of the
test:
* OK if the code should compile,
* BAD if the code shouldn't compile, or
* Any other single line string which the code, when run, should produce.
  Whitespace may be trimmed from the front or back.


   *** Compiling ***
...
main() {
}
... OK

...
main() {
	bad
}
... BAD


   *** Comments ***
...
main() {
  out(1);
  /* out(2); /* out(3); */ // */
  /* garbage */
  out(4); // out(5); garbage
  out(6);
}
... 1 4 6


   *** Variables ***
...
f(a, b) {
  out(a);
  out(b);
}
main() {
  a = 1;
  b = a;
  out(b);
  f(2, 3);
}
... 1 2 3


   *** Operators correctness ***
...
main() {
  /* Unop */
  out(-3);
  out(+ - + - + - + 4);
  out(!0);
  out(!2);
  out(!!2);
  out(~10);
  out(~~10);
}
... -3 -4 1 0 1 -11 10

...
main() {
  /* increment and decrement */
  a = 0;
  out(a++);
  out(a);
  out(a--);
  out(a);
  out(++a);
  out(a);
  out(--a);
  out(a);
  out(a+++a++);
  out(a);
  out(a--+a--);
  out(a);
}
... 0 1 1 0 1 1 0 0 1 2 3 0

...
main() {
  /* Arithmetic binops */
  out(3+1);
  out(3+-1);
  out(-2+-2);
  out(3-1);
  out(3- -1);
  out(-1- -2);
  out(3*2);
  out(-2*3);
  out(-1*-1);
  out(12/4);
  out(6/-2);
  out(-5/-5);
  out(10%4);
  out(10%-4);
  out(-10%4);
  out(-10%-4);
}
... 4 2 -4 2 4 1 6 -6 1 3 -3 1 2 2 -2 -2

...
main() {
  /* Bitwise binops */
  out(3<<2);
  out(12>>2);
  out(1|4);
  out(3&5);
  out(3^5);
}
... 12 3 5 1 6

...
main() {
  /* Assign binops */
  a = 0; a += 2; out(a);
  a = 0; a -= 2; out(a);
  a = 2; a *= 3; out(a);
  a = 6; a /= 2; out(a);
  a = 7; a %= 4; out(a);

  a = 3; a <<= 2; out(a);
  a = 12; a >>= 2; out(a);
  a = 1; a |= 4; out(a);
  a = 3; a &= 5; out(a);
  a = 3; a ^= 5; out(a);
}
... 2 -2 6 3 3 12 3 5 1 6

...
main() {
  /* Logic binops */
  out(-2>-1);
  out(0>-1);
  out(0>0);
  out(1>0);

  out(-2>=-1);
  out(0>=-1);
  out(0>=0);
  out(1>=0);

  out(-1<-2);
  out(-2<0);
  out(1<1);
  out(0<1);

  out(-1<=-2);
  out(-2<=0);
  out(1<=1);
  out(0<=1);

  out(1==1);
  out(1==0);
  out(1!=1);
  out(1!=0);

  out(0&&1);
  out(1&&0);
  out(1&&3);
  out(0&&0);

  out(0||0);
  out(1||0);
  out(0||1);
  out(1||3);
}
... 0 1 0 1 0 1 1 1 0 1 0 1 0 1 1 1 1 0 0 1 0 0 1 0 0 1 1 1


   *** Operator precedence ***
...
op(expr, wanted, not_wanted) {
  out((expr == wanted) && (wanted != not_wanted));
}
main() {
   /* left assoc test */
  out(2) * out(3) * out(4);

  /* precedence test */
  op(~2*3,    (~2)*3,    ~(2*3));
  op(1+2*3,   1+(2*3),   (1+2)*3);
  op(1<<2+3,  1<<(2+3),  (1<<2)+3);
  op(1<2+3,   1<(2+3),   (1<2)+3);
  op(-1<1>2,  (-1<1)>2,  -1<(1>2));
  op(1==2>1,  1==(2>1),  (1==2)>1);
  op(2&2==2,  2&(2==2),  (2&2)==2);
  op(1^2&3,   1^(2&2),   (1^2)&2);
  op(3|2^3,   3|(2^2),   (3|2)^2);
  op(0&&2|1,  0&&(2|1),  (0&&2)|1);
  op(1||2&&0, 1||(2&&0), (1||2)&&0);

  /* right assoc test */
  a = 1; b = 2; c = 3;
  a = b = c;
  out(a); out(b); out(c);
}
... 2 3 4 1 1 1 1 1 1 1 1 1 1 1 3 3 3

   *** Function call evaluation order ***
...
f(a, b, c) { out(a); out(b); out(c); }
g(a, b, c) { }
main() {
  f(1, 2, 3);
  g(out(4), out(5), out(6));
}
... 1 2 3 4 5 6


   *** if/else ***
...
main() {
  if (1) out(1);
  else   out(2);

  if (0) out(3);
  else   out(4);

  if (0)      out(5);
  else if (1) out(6);
  else        out(7);
}
... 1 4 6


   *** Nested for/while ***
...
main() {
	for (i = 0; i < 2; i = i + 1) {
		while (0) {
		}
		for (j = 0; j < 2; j = j + 1) {
			out (i + j);
		}
	}
}
... 0 1 1 2

   *** Recursive call test ***
...
fib(x) {
	if (x < 3) return 1;
	return fib(x-1) + fib(x-2);
}
main() {
	out(fib(10));
}
... 55

...
main() {
	a = 2;
	b = 3;
	out (a+b);
}
... 5

...
main() {
	sum = 0;
	for (i = 0; i <= 10; i=i+1)
		sum = sum + i;
	out(sum);
}
... 55

...
func(a) {
	a-1;
}
main() {
	a = 10;
	while(func(a))
		a = func(a);
	out(a);
}
... 1

...
main () {
	if (1) {
		break;
	}
}
... BAD

...
main () {
	break;
}
... BAD

...
break;
main () {
}
... BAD

...
main () {
	for (i = 0; i < 10; i = i + 1) {
		break;
		out(3);
	}
	out(5);
}
... 5

...
main () {
	for (i = 0; i < 10; i = i + 1) {
		if (i > 2) {
			break;
		}
		out(3);
	}
	out(5);
}
... 3 3 3 5

...
main () {
	for (i = 0; i < 4; i = i + 1) {
		if (i == 1) {
			continue;
		}
		out(3);
	}
	out(5);
}
... 3 3 3 5


   *** Exceptions ***
...
/* nested try/catch */
g() {
  throw 4;
}
f() {
  try {
    g();
  } catch (b) {
    out(b);
    throw b-1;
  }
}
main() {
  out(1);
  try {
    f();
    out(2);
  } catch (a) {
    out(a);
  }
  out(5);
}
... 1 4 3 5

...
/* continue/break in a loop */
main() {
  for (i=0; i < 5; i++) {
    try {
      try {
        if (i == 4)
          throw 2;
      } catch {
        break;
      }
      if (i == 2)
        continue;
    } catch { }
    out(i);
  }
  out(-1);
}
... 0 1 3 -1

...
/* return within a try */
f() {
  try {
    return 0;
  } catch {
  }
}

main() {
  try {
    f();
    throw 1;
  } catch (a) {
    out(a);
  }
  out(2);
}
... 1 2

...
main() {
  throw 1;
}
... uncaught exception: 1
